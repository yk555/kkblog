---
title: 硬件结构
date: 2020-07-05 03:00:00
tags: 硬件结构
categories: 操作系统
---

# 1.1 CPU是如何执行程序的？

有这么几个问题：

- a = 1 + 2 这条指令是怎么被CPU运行起来的？
- 软件32位和64位的区别？32位操作系统可以运行在64位系统上吗？64位可以运行在32位上吗？原因又是什么？
- CPU分为32位和64位，64位优势在哪呢，64位性能一定比32位好吗？



本章大纲

- 图灵机的工作方式
- 冯诺依曼模型
- 线路位宽与CPU位宽
- 程序执行的基本过程
- a = 1 + 2 执行具体过程

## 图灵机的工作方式

当我们不太清楚一个事物为什么是这样子的时候，我们应该去看看它的历史。它在时间潮流中的变化决定它现在出现在你面前的模样。

图灵机是很早就提出的抽象计算模型，下面是它的大概模样

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1657878607869-80563d9d-6634-4abe-825b-11a0f9d7b0af.png)

图灵机的基本组成如下：

- 有一条纸带，由一个一个的格子组成，纸带好比内存，格子中的数据就像内存中的数据。
- 有一个读写头，读写头可以读取纸带上的任意格子的字符
- 头上有一些部件，比如存储单元、控制单元、以及运算单元。分别用于存储数据，识别字符以及控制程序流程，执行运算指令

## 冯诺依曼模型

冯诺依曼遵循图灵机的设计提出了在现在依旧符合的冯诺依曼模型

定义了计算机基本机构：**运算器、控制器、存储器、输入、输出设备**。这五个部分被称为**冯诺依曼模型**

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1657879160879-c965c3d7-a5fe-4a79-bb24-0099d7d72971.svg)

运算器、控制器是在中央处理器里的，存储器就是我们常见的内存，输入输出设备就是计算机外接的设备。

存储器和输入输出设备要是与中央处理器打交道的话，离不开总线。



![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1657879168530-48d6f832-9a09-4454-8f88-772b04d45b3a.webp)

下面介绍 内存、中央处理器、总线、输入输出设备

### 内存

内存这一个存储区域是线性的。存储数据的基本单位是字节（byte），1字节==8位（bit）。每一个字节对应一个内存地址。

内存地址是从0开始的，自增，最后一个地址为总大小 - 1，和数组差不多性质。所以内存读写任何一个数据的速度是一样的

### 中央处理器

即CPU，有32位和64位，区别在于一次能计算多少字节数据。

- 32位 -- 4个字节
- 64位 -- 8个字节

这么设计是为了计算更大的数值。

CPU内部还有常见的如寄存器、控制单元、和逻辑运算单元。

为什么已经有存储器内存存储了，还需要寄存器来存储？

因为内存离CPU远，计算速度比较慢

常见的寄存器种类：

- 通用寄存器：用来存放需要进行运算的数据
- 程序计数器：用来存放CPU要执行的下一条指令的**内存地址**
- 指令寄存器：用来存放程序计数器存放的指令，指令本身

### 总线

CPU和内存以及其他设备的通信

分类：

- 地址总线：用于CPU要操作的内存地址
- 数据总线：用于读写内存的数据
- 控制总线：用于发送和接受信号，比如中断、设备复位等信号

读写内存时

- 地址总线指定内存地址
- 控制总线控制读写命令
- 数据总线传输数据

### 输出输出设备

外界与CPU交互，用到了控制总线

------

## 线路位宽与CPU位宽

数据通过线路传输是通过操作电压完成，低电压是0，高电压是1。

一位一位的传输就是串行方式。想一次多传输就应该增加线路。

为了避免低效率的串行传输方式，线路的位宽最好一次就能访问到所有的内存地址。



**CPU要操作内存地址就需要地址总线：**

- 如果地址总线只有一根，能够表示的只有0 和 1所以能够操作的内存地址最大为2，不是同时操作的地址。
- 两条就是 00 01 10 11 四个地址，

即2 ^ 根数

那么要操作4g内存，就需要32条总线，2 ^ 32 = 4 G



上面的是线路位宽，下面是CPU位宽



CPU的位宽不应该小于线路位宽，因为32位的CPU一次只能操作32位的地址总线和数据总线

### 32位如何计算64位大小的数字？

拆分成高低位，然后先算地位，再算进位，再算高位。

而64位CPU就能一次性计算。

所以如果32位和64位一起计算32位可能没什么差别，但是当计算64位时64位才会有优势。

另外，32位CPU最大只能操作4GB内存条，装了8g也没有用。64位则是2^64

## 程序执行的基本过程

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658114475515-c4d516d0-05b1-437a-a853-5320156fd4d6.png)

- 第一步，CPU根据**程序计数器**获取到**存储指令的内存地址**，然后控制单元操作**地址总线**访问内存地址，通知内存准备数据，准备好数据后，通过**数据总线**将指令内容传给CPU，CPU收到后存入到**指令寄存器**
- CPU分析**指令寄存器**中的指令，确定**指令的类型和参数**，如果是**计算**类型的指令，就把指令交给**逻辑运算单元**运算，如果是**存储**类型的指令，就交给**控制单元**执行。
- 第三步**，CPU执行完指令后，程序计数器自增**，表示指向下一条指令，大小由CPU位宽决定，比如**32位CPU，一条指令大小就是4字节，需要4个地址存放，程序计数器就自增4**

这个往复过程就是CPU的指令周期



## a = 1 + 2执行具体过程

首先CPU是不认识 a =  1 + 2的，所以要想跑起程序就需要把整个程序翻译成汇编语言，整个过程就叫汇编。



针对汇编代码，需要汇编器翻译成机器码，由01组成，这个就是计算机指令，CPU能够认识。



### a = 1 + 2 在 32位CPU的执行过程：

程序编译过程中，编译器通过分析代码，能够发现1 和 2 是数据，内存会有个叫数据段的区域来存放这些数据。

如图

- 数据 1 被存放到 0x100 位置；
- 数据 2 被存放到 0x104 位置；

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658115884206-69b9c67f-9703-4f7d-85ce-b0aa3e6424a5.png)

存放指令的地方叫正文段

存放数据的地方叫数据段

编译器会把a = 1 + 2 翻译成4条指令存放到正文段。

- 0x200 load 将数据1 装入 R0寄存器
- 0x204 load 将数据2 装入 R1寄存器
- 0x208 add 将R0 和 R1 相机，并把结果放到寄存器R2
- 0x20c store 将寄存器R2的数据存回0x108地址就是变量a的地址

再提一句就是，32位CPU一条指令4个字节，也就是4个内存地址



## 指令

指令其实指的是机器码，但是为了方便理解，这里说的是汇编代码。CPU通过解析机器码来知道指令的内容。

不同的CPU有不同的指令集，也对应不同的机器码，下面是最简单的MIPS指令集，来了解机器码是如何生成的。

MIPS 的指令是一个 32 位的整数，高 6 位代表着操作码，表示这条指令是一条什么样的指令，剩下的 26 位不同指令类型所表示的内容也就不相同，主要有三种类型R、I 和 J。

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658116311398-3ca455e0-d06f-4008-829d-7c88b2a1a32c.png)

- R指令，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移后面还有唯一操作的位移量，最后的功能码则是前面的操作码不够的时候，扩展操作码来表示对应的具体指令的。
- I指令，用在数据传输、条件分支等。没有位移量、功能码、和第三个寄存器。三部分合并成一个地址值或一个常数
- J指令用于跳转，后面26位全表示跳转后的地址 

下面举例：add指令将寄存器R0和R1的数据相加，并把结果放入到R2，翻译成机器码

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658135226787-eaf98ecc-c75b-46c2-bb1e-81b91a7f1a2c.png)

加和运算add指令属于R指令类型



编译器在编译程序的时候会构造指令，CPU执行时会解析指令。指令的编码与解码。

在此基础上，现代大多是CPU都是使用**流水线**的方式来执行指令。

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658135540524-9416d824-4a33-46cd-b57b-bff21e82587b.png)

四个阶段的具体含义？

1. 通过程序计数器读取响应内存地址的指令 Fetch 取得指令
2. 对指令进行解码 Decode 指令译码
3. 执行指令 Execution 执行指令
4. 将计算结果放入寄存器或者内存，Store 数据回写



上面4个步骤叫做指令周期。

不同阶段由不同计算机组件完成：

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658135759860-dbf333db-a228-473b-8d15-fabf1e2486da.png)

- 指令都是存储在存储器中，通过程序计数器和指令寄存器取指令的过程都是由控制器操作的。
- 译码--控制器
- 执行时，算术由算术逻辑单元负责，跳转啥的由控制器负责

### 指令的类型

从功能出发，和上面不要混肴，上面有一个是指令集，是具体的体现：

- 数据传输类型 store/load 寄存器与内存 mov 内存与内存
- 运算类型 加减乘除
- 跳转类型 if-else swit-case 函数调用
- 信号类型 trap 中断
- 闲置类型 nop CPU空转



### 指令的执行速度

CPU的硬件参数GHZ ，1GHZ表示1秒能够产生1G次脉冲信

号，每一次脉冲信号高低电平的转换就是一个时钟周期。

CPU在一个时钟周期内，只能完成一次最基本的动作，时钟频率越高时钟周期越短，工作速度越快。

**一个时钟周期能够执行一条指令吗？**

不能。大多数指令都不能，而且不同的指令需要的时钟周期也不一样。乘法比加法多。



**如何让程序跑的更快？**

消耗的CPU时间少，说明程序是快的，对于程序的CPU执行时间可以拆解成CPU时钟周期数和时钟周期时间的乘积

![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2054/1658152623983-d07caff1-d575-4e7a-b987-52e22952aac7.png)

时钟周期时间即主频。主频越高说明运行速度越快。比如2.4GHZCPU，时钟周期时间就是 1/2.4G

但是主频一般来说是相对固定的，所以我们应该去减少CPU时钟周期数。

CPU时钟周期数 = 指令数 * 每天指令的平均时钟周期数CPI

那对于如何让程序跑的更快这个问题的答案就出来了？

- 指令数，可以靠编译器，同样的代码在不同的编译器中编译出来的指令不一样
- 每条指令的平均时钟周期数CPI：大多数CPU已使用**流水线**技术，让一条指令所需要的CPU时钟周期数尽可能的少。
- 时钟周期时间：超频技术，打开超频意味着把CPU内部时钟调快了。代价是热量和崩溃。

很多厂商为了跑分而跑分，基本都是在这三个方面入手的哦，特别是超频这一块



## 总结

# 1.2 磁盘比内存缓慢几万倍？

1

2