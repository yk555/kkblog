{"meta":{"title":"Hexo","subtitle":"","description":"kk的博客啦","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2020-08-21T16:00:00.000Z","updated":"2022-07-22T07:19:11.553Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-21T16:14:46.000Z","updated":"2022-07-22T07:12:14.907Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring自动装配原理","slug":"spring/Spring自动装配原理","date":"2022-07-31T16:00:00.000Z","updated":"2022-08-02T01:03:20.162Z","comments":true,"path":"2022/08/01/spring/Spring自动装配原理/","link":"","permalink":"http://example.com/2022/08/01/spring/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"","text":"一句话解释提到自动装配原理，就会提到Springboot的注解@SpringBootApplication，这个注解由@SpringbootConfiguration 和 @EnableAutoConfiguration以及@ComponentScan最重要的注解组成。其中@EnableAutoConfiguration注解通过读取META-INF&#x2F;spring.factories文件中的信息，以读取一些基础配置，比如redis、kafka。@ComponentScan注解则是用来扫描应用程序中的配置类，比如自己写的bean的配置类。@SpringbootConfiguration，功能与@Configuration差不多，其加在启动类上的作用是，将启动类也标志为配置类，在启动时，将自己也扫描进去。 详细的解释@SpringBootApplication的其中3个重要注解： @SpringBootConfiguration 标识是一个配置类 @EnableAutoConfiguration 启用Spring Boot 的自动配置机制 @ComponentScan 扫描应用程序中的配置类 对注解 @EnableAutoConfiguration 的解释看了几片八股文，说一说自己的理解吧 @EnabkeAutoConfiguration中有一个重要的注解--@Import ，import的内容按照字面意思则是自动配置导入选择器。 其中有个process（）方法，方法中调用getAutoConfigurationEntry方法 再进入其中，其中调用了getCandidateConfigurations方法 再进入getCandidateConfigurations方法，方法中调用了SpringFactoriesLoader的loadFactoryNames方法 再进入loadFactoryNames其中，调用了loadSpringFactories方法 最后会发现，这里加载了META-INF&#x2F;spring.factories中的配置信息。 我们进入spring-boot-autoconfigure包中的META-INF&#x2F;spring.factories，能够看到类似于这样的一些配置类信息。 总结用官方的话来说，Springboot的自动配置，就是尝试根据用户添加的jar依赖项配置您的Spring应用程序。 要是想对自动配置的理解更深的话，应该去体会一下Spring是如何配置的。 参考的文章SpringBoot系列–自动装配原理1 Spring官方文档 自动装配脑图 Tipscreate：2022&#x2F;8&#x2F;1 内容比较简陋，将会在后期深入学习后继续补充和更新相关内容。","categories":[{"name":"Springboot","slug":"Springboot","permalink":"http://example.com/categories/Springboot/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://example.com/tags/Springboot/"}]},{"title":"并发基础中的Future异步回调模式","slug":"netty/并发基础中的Future异步回调模式","date":"2022-01-08T19:00:00.000Z","updated":"2022-07-25T06:54:22.462Z","comments":true,"path":"2022/01/09/netty/并发基础中的Future异步回调模式/","link":"","permalink":"http://example.com/2022/01/09/netty/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%9A%84Future%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"在netty中使用了很多回调技术，并且基于java的回调设计了一整套异步回调接口和实现。 这篇文章从Java Future入手，再到第三方异步回调技术–谷歌的Guava Future，最后介绍Netty的异步回调技术。 在文章中的所有demo都采用“泡茶”的案例 主线程：负责启动和等待其他线程 清洗线程 烧水线程 Join异步阻塞join的原理与作用是，阻塞当前线程，直到准备合并的目标线程的执行完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.example;public class JoinDemo &#123; public static final int SLEEP_GAP = 5000; public static String getCurThreadName() &#123; return Thread.currentThread().getName(); &#125; static class HotwaterThread extends Thread &#123; public HotwaterThread() &#123; super(&quot;** 烧水-Thread&quot;); &#125; public void run() &#123; try &#123; System.out.println(&quot;洗好茶壶&quot;); System.out.println(&quot;灌水&quot;); System.out.println(&quot;放在火上&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;水烧开了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); &#125; System.out.println(&quot;运行结束&quot;); &#125; &#125; static class WashThread extends Thread &#123; public WashThread() &#123; super(&quot;$$ 清洗-Thread&quot;); &#125; public void run() &#123; try &#123; System.out.println(&quot;洗茶壶&quot;); System.out.println(&quot;洗茶杯&quot;); System.out.println(&quot;拿茶叶&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;洗完了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); &#125; System.out.println(&quot;运行结束&quot;); &#125; &#125; public static void main(String[] args) &#123; Thread h = new HotwaterThread(); Thread w = new WashThread(); h.start(); w.start(); try &#123; h.join(); w.join(); Thread.currentThread().setName(&quot;主线程&quot;); System.out.println(&quot;泡茶喝&quot;); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(&quot;end&quot;); &#125;&#125; join有三个重载版本： void join () : A线程等待B线程执行结束后，A线程重新恢复执行 void join(long millis) ：A线程等待B线程最长millis毫秒，超过后A重新恢复执行 void join(long millis, int nanos)A线程等待B线程最长mills毫秒 + nanos纳秒 容易混淆的地方： join是实例方法，不是静态方法，所以需要用线程对象去调用join，例如thread.join join调用时，不是线程所指向的目标线程阻塞，而是当前线程阻塞。 只有等到目标线程完成或超时，当前线程才能恢复执行 join的问题:被合并的线程没有返回值，即调用join后，没有返回值。 例如，在上述代码中，main进程无法得知其他线程的运行结果。 所以想要获得异步线程的执行结果，下面就介绍Java的FutureTask系列 FutureTask异步回调FutureTask方式在java.util.concurrent包中。最重要的就是FutureTask 类和 Callable接口 Callable接口新事物的出现，一定是为了解决旧事物的一些缺陷。 提到Callable接口，就离不开Runnable接口，Runnable有一个重要的问题，即它的run方法没有返回值的。所以Runnable不能用于需要有返回值的场景。 Runnable接口是在Java多线程中表示线程的业务代码的抽象接口 为了解决Runnable的问题，所以才有了Callable 12345678910package java.util.concurrent;@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;package java.lang;@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Callable是一个泛型接口，唯一方法call的返回值类型为泛型形参的实际类型，并且还有一个Exception，容许方法内部的异常不经过捕获。 阿Callable方法可以与Runnable相对应，可以看成更强大的Runnable。 但他们也有不同的地方： Callable接口的实例不能作为Thread线程实例的target来使用。Runnable接口实例可以作为Thread线程实例的target构造参数，开启一个Thread线程。 target是什么？ 查看Thread源码可以得知，target是Runable类的，在Thread初始化时有使用。target作为参数传入Thread构造函数，构造函数调用init函数初始时也将target传入。并且在thread run中调用的也是Runnable的run方法。 12345678910111213141516171819202122public class Thread implements Runnable &#123; /* What will be run. */ private Runnable target; @Override protected Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException(); &#125; //Thread的构造器有很多种，只列了一种 public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; &#125; 但是呢，java的线程类型只有Thread，callable要是想利用Thread的话，就要想办法将自己赋值给Runnable类型的target，所以需要一个FutureTask类来进行所谓的搭桥。 FutureTask类12345678public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; 直接查看源码可以发现，FutureTask实现了RunnableFuture，而RunnableFuture则继承了Runnable和Future 所以可以作为target传递给Thread。但是想要获取到Callable的异步执行结果就不应该使用它的call方法，而是通过FutureTask类的相应方法去获取。FutureTask实现了Future接口，Future接口则是提供了判断、获取、取消并发任务结果的功能。 123456789package java.util.concurrent;public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future接口提供的get方法是阻塞的，如果并发任务没有完成就会等待并发任务完成。可以增加时间约束。 总结一下，FutureTask通过间接继承了Runnable，从而能够作为Thread的target, 然后Callable作为参数传入其中，此外Future提供了获取异步任务执行结果的方法，FutureTask实现了其方法。到这里Future成功搭起来看Callable和Thread的桥梁，并且实现获取异步任务结果的方式。 回到FutureTask中，变量Callable代表异步执行的逻辑，我们需要保存结果，保存在哪呢？ 查看源码可以看到，FutureTask中有一个run方法是Runnable接口的，它能作为Target目标去执行，然后 1234567891011121314151617181920212223242526272829303132public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; run方法中有个set方法 1234567protected void set(V v) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); &#125; &#125; 最终保存在outcome属性中 private Object outcome 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.example;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class JavaFutureDemo &#123; public static final int SLEEP_GAP = 5000; public static String getCurThreadName() &#123; return Thread.currentThread().getName(); &#125; static class HotWaterJob implements Callable&lt;Boolean&gt; &#123; @Override public Boolean call() throws Exception &#123; try &#123; System.out.println(&quot;洗好茶壶&quot;); System.out.println(&quot;灌水&quot;); System.out.println(&quot;放在火上&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;水烧开了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); return false; &#125; System.out.println(&quot;运行结束&quot;); return true; &#125; &#125; static class WashJon implements Callable&lt;Boolean&gt; &#123; @Override public Boolean call() throws Exception &#123; try &#123; System.out.println(&quot;洗茶壶&quot;); System.out.println(&quot;洗茶杯&quot;); System.out.println(&quot;拿茶叶&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;洗完了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); return false; &#125; System.out.println(&quot;运行结束&quot;); return true; &#125; &#125; public static void drinkTea(boolean waterOK, boolean cupOk) &#123; if (waterOK &amp;&amp; cupOk) &#123; System.out.println(&quot;泡茶喝&quot;); &#125; else if (!waterOK) &#123; System.out.println(&quot;烧水失败，没有茶喝了&quot;); &#125; else if (!cupOk) &#123; System.out.println(&quot;杯子洗不了，没有茶喝了&quot;); &#125; &#125; public static void main(String args[]) &#123; Callable&lt;Boolean&gt; hJob = new HotWaterJob(); FutureTask&lt;Boolean&gt; hTask = new FutureTask&lt;Boolean&gt;(hJob); Thread hThread = new Thread(hTask, &quot;** 烧水-Thread&quot;); Callable&lt;Boolean&gt; wJob = new WashJon(); FutureTask&lt;Boolean&gt; wTask = new FutureTask&lt;Boolean&gt;(wJob); Thread wThread = new Thread(wTask, &quot;$$ 清洗-Thread&quot; ); hThread.start(); wThread.start(); Thread.currentThread().setName(&quot;主线程&quot;); try &#123; boolean watereOk = hTask.get(); boolean cupOk = wTask.get(); drinkTea(watereOk, cupOk); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(e); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(&quot;end&quot;); &#125;&#125; 虽然可以通过get获取异步执行的结果，但是并不高明，因为get实际上还是阻塞的，就是主线程调用get时，主线程也会阻塞，和join差不多。 原生JavaAPI除了阻塞模式的获取结果外，没有实现非阻塞的，需要引入别的框架比如谷歌的Guava。 谷歌Guava的异步回调Guava是谷歌公司提供的Java扩展包，是一种异步回调的解决方案。 新增了一个ListenableFuture接口，继承了Java的Future接口，使得Java的Future异步任务，在Guava中能够被监控和获得非阻塞异步执行的结果 引入一个新的接口FutureCallback，根据异步执行结果完成不同的回调处理，能够处理异步结果啦。 FutureCallback负责异步任务完成后的监听逻辑，相当于处理异步结果 有两个方法： onSuccess 异步任务成功后被回调，异步任务的结果作为onSuccess的参数 onFailure 异步任务异常被回调，异步任务的结果作为onFailure的参数 12345@GwtCompatiblepublic interface FutureCallback&lt;V&gt; &#123; void onSuccess(@Nullable V result); void onFailure(Throwable t);&#125; 看起来与Callable相似，但完全不一样： Callable代表异步执行逻辑 FutureCallback代表的是异步任务完成后对结果的处理工作 Guava FutureCallback只是对Java Future异步执行的增强，所以使用Guava需要Java Callable，简单来说只有Java的Callable任务执行的结果出来以后才能执行FutureCallback 如何实现这种监控关系呢？ 引入ListenableFuture，获取异步执行结果 ListenableFuture这里直接上源码 1234@GwtCompatiblepublic interface ListenableFuture&lt;V&gt; extends Future&lt;V&gt; &#123; void addListener(Runnable listener, Executor executor);&#125; ListenableFuture在Future的基础上增加了addListener方法，目的是将FutureCallback的任务封装成一个内部的Runnable异步回调任务。在Callable异步完成后，回调。但是这个方法只在内部使用，一般不调用。 那如何将FutureCallback绑定到ListenableFuture任务呢？ 使用Guava的Futures工具类，addcallback可以绑定。 123456789101112ListenableFuture&lt;Boolean&gt; hotFuture = gPool.submit(hotJob); Futures.addCallback(hotFuture, new FutureCallback&lt;Boolean&gt;() &#123; public void onSuccess(Boolean r) &#123; if (r) &#123; mainJob.waterOk = true; &#125; &#125; public void onFailure(Throwable throwable) &#123; System.out.println(&quot;烧水失败&quot;); &#125; &#125;); 如果Guava的ListenableFuture 是 对Java Future 的扩展，都表示异步任务，那Guava的异步任务从何而来？ ListenableFuture的异步任务异步任务的实例主要是通过向线程池提交Callable任务的方式获取，这里的线程池是Guava的不是Java的，另外FutureTask的异步任务实例是直接将Callable传入构造器。 12ExecutorService jPool = Executors.newFixedThreadPool(10);ListeningExecutorService gPool = MoreExecutors.listeningDecorator(jPool); 流程： 创建Callable异步任务 创建Guava线程池 提交Callable获取ListenableFuture异步任务实例 创建FutureCallback，绑定ListenableFuture 泡茶实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package org.example;import com.google.common.util.concurrent.*;import javax.annotation.Nullable;import java.util.concurrent.Callable;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class GuavaFutureDemo &#123; public static final int SLEEP_GAP = 5000; public static String getCurThreadName() &#123; return Thread.currentThread().getName(); &#125; static class HotWaterJob implements Callable&lt;Boolean&gt; &#123; @Override public Boolean call() throws Exception &#123; try &#123; System.out.println(&quot;洗好茶壶&quot;); System.out.println(&quot;灌水&quot;); System.out.println(&quot;放在火上&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;水烧开了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); return false; &#125; System.out.println(&quot;运行结束&quot;); return true; &#125; &#125; static class WashJon implements Callable&lt;Boolean&gt; &#123; @Override public Boolean call() throws Exception &#123; try &#123; System.out.println(&quot;洗茶壶&quot;); System.out.println(&quot;洗茶杯&quot;); System.out.println(&quot;拿茶叶&quot;); Thread.sleep(SLEEP_GAP); System.out.println(&quot;洗完了&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发送异常被中断&quot;); return false; &#125; System.out.println(&quot;运行结束&quot;); return true; &#125; &#125; static class MainJob implements Runnable &#123; boolean waterOk = false; boolean cupOk = false; int gap = SLEEP_GAP / 10; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(gap); System.out.println(&quot;读书中&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(getCurThreadName() + &quot;中断&quot;); &#125; if (waterOk &amp;&amp; cupOk) &#123; drinkTea(waterOk, cupOk); break; &#125; &#125; &#125; public void drinkTea(boolean waterOK, boolean cupOk) &#123; if (waterOK &amp;&amp; cupOk) &#123; System.out.println(&quot;泡茶喝&quot;); &#125; else if (!waterOK) &#123; System.out.println(&quot;烧水失败，没有茶喝了&quot;); &#125; else if (!cupOk) &#123; System.out.println(&quot;杯子洗不了，没有茶喝了&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; final MainJob mainJob = new MainJob(); Thread mainThread = new Thread(mainJob); mainThread.setName(&quot;主线程&quot;); mainThread.start(); Callable&lt;Boolean&gt; hotJob = new HotWaterJob(); Callable&lt;Boolean&gt; washJob = new WashJon(); ExecutorService jPool = Executors.newFixedThreadPool(10); ListeningExecutorService gPool = MoreExecutors.listeningDecorator(jPool); ListenableFuture&lt;Boolean&gt; hotFuture = gPool.submit(hotJob); Futures.addCallback(hotFuture, new FutureCallback&lt;Boolean&gt;() &#123; public void onSuccess(Boolean r) &#123; if (r) &#123; mainJob.waterOk = true; &#125; &#125; public void onFailure(Throwable throwable) &#123; System.out.println(&quot;烧水失败&quot;); &#125; &#125;); ListenableFuture&lt;Boolean&gt; washFuture = gPool.submit(washJob); Futures.addCallback(hotFuture, new FutureCallback&lt;Boolean&gt;() &#123; public void onSuccess(Boolean r) &#123; if (r) &#123; mainJob.cupOk = true; &#125; &#125; public void onFailure(Throwable throwable) &#123; System.out.println(&quot;杯子洗不了&quot;); &#125; &#125;); &#125;&#125; Guava非阻塞的原因与理解 Netty的异步回调模式在netty源码中大量使用了异步回调模式，在netty业务开发层面，netty应用的是handle处理器中的业务处理代码也是异步的。所以了解netty的异步回调是十分重要的。 Netty扩展了Java Future的异步任务： 继承Java Future接口并增强，使其方法可以非阻塞。 引入GeneriFutureListener，用于表示异步任务完成的监控器，与Guava的FutureCallback不同，Netty使用的是监控器模式，异步任务完成后回调逻辑抽象成了Lisener监听器接口。可以将GenericFutureListener监听器加入Netty的异步任务Future中，实现对异步任务执行状态的事件监听。 在异步非阻塞回调思路上和Guava是一致的。 GenericFutureListener接口该接口位于io.netty.util.concurrent 直接上源码 GenericFutureListener拥有一个回调方法operationComplete,回调代码写在这。 而父接口EventListner是空接口，没有任何方法，起标识作用。 Netty Future 接口netty对Future进行了扩展，对执行的过程进行监控，对异步回调完成事件进行监听。 1 Future接口一般不会直接使用，而是会使用子接口。Netty有一系列的子接口，代表不同类型的异步任务如ChannelFuture接口。 ChannelFuture表示通道IO操作的异步任务，如果在通道的异步IO操作完成后执行回调就需要ChannelFuture","categories":[{"name":"netty","slug":"netty","permalink":"http://example.com/categories/netty/"}],"tags":[{"name":"异步回调","slug":"异步回调","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"},{"name":"Future","slug":"Future","permalink":"http://example.com/tags/Future/"}]},{"title":"Reacotor模式","slug":"netty/Reactor模式","date":"2022-01-07T19:00:00.000Z","updated":"2022-07-25T06:55:09.341Z","comments":true,"path":"2022/01/08/netty/Reactor模式/","link":"","permalink":"http://example.com/2022/01/08/netty/Reactor%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是Reactor模式？Reactor模式有两大角色组成： Reactor反应器线程，负责响应IO事件，并且分发到Handles处理器中 Handles处理器，非阻塞的执行业务处理逻辑 为什么需要Reactor模式？多线程OIO的缺陷在最初的Java OIO程序中，使用的方式是while循环，不断地监听是否有新的连接。相当于，如果前面的handle没有处理完，就不能处理后面的连接。吞吐很低。 为了解决这种情况，后来出现了一个叫做connection per thread模式。就是为每一个连接分配一个线程，包括监听也是独立的线程。 如果在这种多线程OIO的情况下，每一个线程处理多个连接可以吗？当然是不可以的，因为这里的每个socket连接的读写操作都是阻塞的，无论如何都只能处理一个IO操作。缺点是，需要消耗大量的线程资源。 为了做到一个线程处理多个连接，引出反应器模式的简单版本 单线程Reactor反应器即reactor反应器和handler处理器在同一个线程 缺点：由于在同一个线程，当某个handle阻塞时其他handle得不到执行。 为了真正解决问题，引入 多线程Reactor反应器升级： 升级handler处理器，线程池 多个reactor处理器 将IOHandler和监听事件的反应器线程隔离，不会相互阻塞。 反应器模式和生产者消费者模式的对比 反应器是基于查询的，没有专门的队列去缓冲存储IO事件，查询到事件后，反应器会根据不同IO选择器分发。 反应器模式和观察者模式的对比 观察者模式，发布一个主题后，会通知所有观察着处理。 反应器模式一般一个事件绑定一个handler","categories":[{"name":"netty","slug":"netty","permalink":"http://example.com/categories/netty/"}],"tags":[{"name":"Reactor模式","slug":"Reactor模式","permalink":"http://example.com/tags/Reactor%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaNIO","slug":"netty/JavaNIO","date":"2022-01-05T19:00:00.000Z","updated":"2022-07-25T06:48:06.886Z","comments":true,"path":"2022/01/06/netty/JavaNIO/","link":"","permalink":"http://example.com/2022/01/06/netty/JavaNIO/","excerpt":"","text":"一切还要从JavaNIO说起。 JavaNIO是基于IO多路复用技术，NIO（new IO） 弥补了老式的OIO同步阻塞的不足 他们有何不同呢？ OIO面向流， NIO面向缓冲区 因为是面向流的，所以导致OIO只能顺序读取 OIO阻塞， NIO非阻塞 OIO没用选择器，NIO有选择器，但需要底层支持 JavaNIO有三个核心组件 Channel 通道 Buffer 缓冲区 Selector选择器 可以理解为，buffer是存储数据的地方，channel是运输数据的载体，select用于检查多个channel状态变更 Buffer类能够覆盖所有基本类型，还包括用于内存映射的MappedByteBuffer Byte，Char, Double, Float, Int , Long, Short buffer类的基本属性 capacity–容量 position–当前位置 limit–读写的最大上限 mark–标记当前位置，并且能够在reset（）将position回到标记的位置 重要方法 allocate（）–创建缓冲区 put（）–写入到缓冲区 flip() – 翻转，将写模式切换成读模式 get()–从缓冲区取 rewind（）倒带相当于重新读缓冲区里的东西 mark()和reset() clear（）清空缓冲区并且变为写模式。 Channel类四种分类： FileChannel SocketChannel ServerSocketChannel DatagramChannel Selector类channel将自己的事件注册到Selector中 IO事件类型有以下四种： 可读 SelectionKey.OP_READ 可写 SelectionKey.OP_WRITE 连接 SelectionKey.OP_CONNECT 接收 SelectionKey.OP_ACCEPT 为什么FileChannel不能被选择器复用？ 因为没有继承SelectableChannel SelectableChannel 提供了实现通道的可选择性所需要的公共方法 FilChannel是阻塞的，不能设置成非阻塞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class NoBlockServer &#123; public static void main(String[] args) throws IOException &#123; // 1.获取通道 ServerSocketChannel server = ServerSocketChannel.open(); // 2.切换成非阻塞模式 server.configureBlocking(false); // 3. 绑定连接 server.bind(new InetSocketAddress(6666)); // 4. 获取选择器 Selector selector = Selector.open(); // 4.1将通道注册到选择器上，指定接收“监听通道”事件 server.register(selector, SelectionKey.OP_ACCEPT); // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) &#123; // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) &#123; SelectionKey selectionKey = iterator.next(); // 接收事件就绪 if (selectionKey.isAcceptable()) &#123; // 8. 获取客户端的链接 SocketChannel client = server.accept(); // 8.1 切换成非阻塞状态 client.configureBlocking(false); // 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件) client.register(selector, SelectionKey.OP_READ); &#125; else if (selectionKey.isReadable()) &#123; // 读事件就绪 // 9. 获取当前选择器读就绪状态的通道 SocketChannel client = (SocketChannel) selectionKey.channel(); // 9.1读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建) FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.png&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE); while (client.read(buffer) &gt; 0) &#123; // 在读之前都要切换成读模式 buffer.flip(); outChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); &#125; &#125; // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class NoBlockClient &#123; public static void main(String[] args) throws IOException &#123; // 1. 获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666)); // 1.1切换成非阻塞模式 socketChannel.configureBlocking(false); // 1.2获取选择器 Selector selector = Selector.open(); // 1.3将通道注册到选择器中，获取服务端返回的数据 socketChannel.register(selector, SelectionKey.OP_READ); // 2. 发送一张图片给服务端吧 FileChannel fileChannel = FileChannel.open(Paths.get(&quot;X:\\\\Users\\\\ozc\\\\Desktop\\\\面试造火箭\\\\1.png&quot;), StandardOpenOption.READ); // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢 ByteBuffer buffer = ByteBuffer.allocate(1024); // 4.读取本地文件(图片)，发送到服务器 while (fileChannel.read(buffer) != -1) &#123; // 在读之前都要切换成读模式 buffer.flip(); socketChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); &#125; // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) &#123; // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) &#123; SelectionKey selectionKey = iterator.next(); // 8. 读事件就绪 if (selectionKey.isReadable()) &#123; // 8.1得到对应的通道 SocketChannel channel = (SocketChannel) selectionKey.channel(); ByteBuffer responseBuffer = ByteBuffer.allocate(1024); // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收 int readBytes = channel.read(responseBuffer); if (readBytes &gt; 0) &#123; // 切换读模式 responseBuffer.flip(); System.out.println(new String(responseBuffer.array(), 0, readBytes)); &#125; &#125; // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); &#125; &#125; &#125;&#125; Linux下的IO多路复用技术文件句柄数的限制 默认1024,也就是一个进程最多接受1024个socket连接 从基础开始讲起，文件句柄，也叫文件描述符。 在linux中文件分为，普通文件、目录文件、链接文件、和设备文件 文件描述符是内核为了高效管理已被打开的文件所创建的索引。是一个非负整数（通常是小数） ulimit 用来显示-修改当前用户进程的一些信息，-n是与文件句柄相关。 三种修改句柄方式 ulimit -n 10000 当终端工具退出时就会失效 向 &#x2F;etc&#x2F;rc.local添加 ulimit -SHn 10000 终极 解除 修改极限配置文件 soft nofile 10000 hard nofile 10000 ElasticSearch必须修改 此外，linux对文件的操作实际上是通过文件描述符，而IO复用模型就是通过一个线程监控多个文件描述符，当某个文件描述符准备就绪时，就去通知程序做处理。这样不仅单个连接处理的快，还能处理更多的连接。 linux下的IO复用模型就是select&#x2F;epoll函数 select和epoll的区别select 函数支持的最大的连接数是1024或者2048，因为在select函数要传入fd_set参数（看操作系统的位数） fd_set是bitmap的数据结构，可以简单理解为只要位为0，就是数据没到缓冲区，为1 到了缓冲区 select函数做的就是每次将fd_set遍历，有变化就通知处理。 epoll 使用epoll_event结构体来处理，不存在最大连接数的限制。并且不是通过遍历的方式，简单理解就是epoll把就绪的文件描述符专门维护了一块空间，每次从就绪列表里边拿。 零拷贝和JavaNIO相关的另一个概念是零拷贝 传统IO情况下，当用户程序发起一次读请求，会调用read相关的系统函数，然后会从用户态切换到内核态，随后CPU告诉DMA去磁盘把数据拷贝到内核空间。内核缓冲区有数据后，CPU就把内核缓冲区数据拷贝到用户缓冲区，最终用户程序拿到数据。 DMA是直接内存访问，允许外部设备直接与内存设备进行数据传输不需要CPU参与的技术 为了内核安全，所以将操作系统划分为用户空间和**内核空间,**读数据会有状态切换。 零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I&#x2F;O操作优化技术。 mmap–内核缓冲区与用户缓冲区共享 sendfile–系统底层函数的支持 下面是比较详细的解释 传统IO过程 read ：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区 write：先把数据写入到socket缓冲区，最后写入网卡设备 过程 用户程序通过read函数向内核发起IO，从用户态切换为内核态，然后再通过DMA将数据从磁盘读到内核缓冲区 CPU将内核缓冲区数据拷贝到用户缓冲区，然后read函数返回，从内核态切换到用户态。 用户程序通过write函数向内核发起IO，从用户态切换到内核态，然后CPU将数据从用户缓冲区拷贝到内核socket缓冲区，然后write返回，从内核态切换到用户态。 最后异步传输到网卡。 可以看出，发生了四次状态切换，CPU拷贝两次。 https://blog.csdn.net/a745233700/article/details/122660332 零拷贝指在进行数据IO时， 数据在用户态下经历了零次CPU拷贝。通过减少内核缓冲区和用户缓冲区之间不必要的cpu数据传输，与用户态和内核态的切换磁环，降低开销提高性能。零拷贝基于PageCache，提升访问缓存数据的性能，同时IO合并与预读（顺序读比随机读性能好）解决机械磁盘寻址慢。 Linux中的零拷贝方式 mmapmmap就是操作系统把内核缓冲区与用户程序共享，也可以说是将用户空间内存映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，反过来也一样。正因如此，就不需要在用户态与内核态之间拷贝数据。 过程： 用户程序调用mmap发起IO，从用户态切换到内核态，通过DMA将数据从磁盘拷贝到内核缓冲区。 mmap返回，从内核态切换到用户态，不需要将数据从内核缓冲区复制到用户缓冲区，因为共享。 用户程序通过write发起IO，从用户态切换到内核态，CPU将数据从内核缓冲区复制到内核socket缓冲区，返回内核态切换为用户态。 DMA异步将socket缓冲区拷贝到网卡 sendfile由于调用read或者write一定会发生两次上下文切换，所以想要减少状态切换，那就把read和write合并起来，在内核中完成磁盘与网卡的数据交互 过程： 用户程序发起sendfile，用户态切换到内核态，DMA将数据从磁盘复制到内存缓冲区 CPU将数据从内核缓冲区复制到socket缓冲区 sendfile系统调用返回，从内核态切换到用户态 DMA异步将socket数据复制到网卡 带DMA收集拷贝功能的sendfilesendfile升级后，引入了SG-DMA，就是对DMA拷贝加入了scatter、gather操作，可以直接将内存缓冲区数据复制到网卡，无需再复制到socket缓冲区，减少CPU拷贝次数。 过程： 用户程序发起sendfile调用，从用户态切换到内核态，DMA将数据从磁盘拷贝到内核缓冲区 不需要CPU将数据复制到socket缓冲区，而是将文件描述符信息复制到socket缓冲区，该描述符包含 内核缓冲区的内存地址、内核缓冲区的偏移量 sendfile返回，从内核态切换到用户态 DMA根据socket缓冲区中描述的地址和偏移量直接将内核缓冲区复制到网卡。 零拷贝的缺点：不允许进程对文件内容做加工再发送，比如数据压缩 零拷贝的应用场景JavaNIO mmap+ write 上文提到过buffer中有个叫mappedBuffer的家伙，同时Filechannel提供了map方法，可以再一个打开的文件和MappedByteBuffer之间建立一个虚拟内存映射，map底层是通过mmap实现的，因此磁盘文件到缓冲区后，用户和内核共享缓冲区。 12345678910111213141516public class MmapTest &#123; public static void main(String[] args) &#123; try &#123; FileChannel readChannel = FileChannel.open(Paths.get(&quot;./jay.txt&quot;), StandardOpenOption.READ); MappedByteBuffer data = readChannel.map(FileChannel.MapMode.READ_ONLY, 0, 1024 * 1024 * 40); FileChannel writeChannel = FileChannel.open(Paths.get(&quot;./siting.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE); //数据传输 writeChannel.write(data); readChannel.close(); writeChannel.close(); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125; sendfile FileChannel 的 transferTo、transferFrom 如果操作系统底层支持的话，transferTo、transferFrom也会使用 sendfile 零拷贝技术来实现数据的传输 12345678910111213141516171819202122@Overridepublic long transferFrom(FileChannel fileChannel, long position, long count) throws IOException &#123; return fileChannel.transferTo(position, count, socketChannel);&#125;public class SendFileTest &#123; public static void main(String[] args) &#123; try &#123; FileChannel readChannel = FileChannel.open(Paths.get(&quot;./jay.txt&quot;), StandardOpenOption.READ); long len = readChannel.size(); long position = readChannel.position(); FileChannel writeChannel = FileChannel.open(Paths.get(&quot;./siting.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE); //数据传输 readChannel.transferTo(position, len, writeChannel); readChannel.close(); writeChannel.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; Netty框架 Netty 的零拷贝主要体现在下面五个方面： （1）在网络通信上，Netty 的接收和发送 ByteBuffer 采用直接内存，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中（为什么拷贝？因为 JVM 会发生 GC 垃圾回收，数据的内存地址会发生变化，直接将堆内的内存地址传给内核，内存地址一旦变了就内核读不到数据了），然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 （2）在文件传输上，Netty 的通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。 （3）在缓存操作上，Netty 提供了CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。 （4）通过 wrap 操作，我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象，进而避免了拷贝操作。 （5）ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。 kafka Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式 零拷贝1 零拷贝2 零拷贝3","categories":[{"name":"netty","slug":"netty","permalink":"http://example.com/categories/netty/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JavaNIo","slug":"JavaNIo","permalink":"http://example.com/tags/JavaNIo/"},{"name":"netty","slug":"netty","permalink":"http://example.com/tags/netty/"},{"name":"零拷贝","slug":"零拷贝","permalink":"http://example.com/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"}]},{"title":"IO多路复用","slug":"netty/IO多路复用","date":"2022-01-04T19:00:00.000Z","updated":"2022-07-25T06:47:19.646Z","comments":true,"path":"2022/01/05/netty/IO多路复用/","link":"","permalink":"http://example.com/2022/01/05/netty/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"什么是Netty？netty是一个高并发的通信框架。 IO读写的基础原理有两种IO 进程缓冲区和内核缓冲区的交互 内核缓冲区和物理设备的交互 四种IO模型同步和异步的区别： 同步是用户线程发起，异步是内核空间发起的 阻塞和非阻塞的区别： 阻塞是发起IO后需要等待IO结束 同步阻塞IO 优点：开发简单。阻塞期间，用户线程挂起，不会占用CPU资源 缺点：一个连接一个线程，不适合高并发 同步非阻塞NIO 优点：用户等待线程过程中不会阻塞，实时性较好 缺点：不断轮询内核，占用CPU时间 指的并不是Java的NIO包， IO多路复用 解决同步非阻塞模型中轮询等待的问题 linux对文件的操作实际上是通过文件描述符，而IO复用模型就是，通过一个进程监听多个文件描述符，一旦某个文件描述符准备就绪，就去通知程序做处理。不仅单个链接处理的快，而且能处理更多链接 异步IO 用户线程通过系统调用注册IO操作，直到完成都不阻塞。 应用程序只需要进行事件的注册与接收，其余工作都要操作系统完成，需要支持 windowsIOCP真正支持，Linux还是IO多路复用， netty也还是IO多路复用 总结到此为止都是高并发IO的底层原理。但即使最先进的模型也需要合理的配置 JavaNIO通信基础Reactor反应器模式并发基础中的Future回调模式","categories":[{"name":"netty","slug":"netty","permalink":"http://example.com/categories/netty/"}],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"http://example.com/tags/IO%E6%A8%A1%E5%9E%8B/"}]},{"title":"硬件结构","slug":"操作系统/硬件结构","date":"2020-07-04T19:00:00.000Z","updated":"2022-07-25T08:28:22.631Z","comments":true,"path":"2020/07/05/操作系统/硬件结构/","link":"","permalink":"http://example.com/2020/07/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.1 CPU是如何执行程序的？有这么几个问题： a &#x3D; 1 + 2 这条指令是怎么被CPU运行起来的？ 软件32位和64位的区别？32位操作系统可以运行在64位系统上吗？64位可以运行在32位上吗？原因又是什么？ CPU分为32位和64位，64位优势在哪呢，64位性能一定比32位好吗？ 本章大纲 图灵机的工作方式 冯诺依曼模型 线路位宽与CPU位宽 程序执行的基本过程 a &#x3D; 1 + 2 执行具体过程 图灵机的工作方式当我们不太清楚一个事物为什么是这样子的时候，我们应该去看看它的历史。它在时间潮流中的变化决定它现在出现在你面前的模样。 图灵机是很早就提出的抽象计算模型，下面是它的大概模样 图灵机的基本组成如下： 有一条纸带，由一个一个的格子组成，纸带好比内存，格子中的数据就像内存中的数据。 有一个读写头，读写头可以读取纸带上的任意格子的字符 头上有一些部件，比如存储单元、控制单元、以及运算单元。分别用于存储数据，识别字符以及控制程序流程，执行运算指令 冯诺依曼模型冯诺依曼遵循图灵机的设计提出了在现在依旧符合的冯诺依曼模型 定义了计算机基本机构：运算器、控制器、存储器、输入、输出设备。这五个部分被称为冯诺依曼模型 运算器、控制器是在中央处理器里的，存储器就是我们常见的内存，输入输出设备就是计算机外接的设备。 存储器和输入输出设备要是与中央处理器打交道的话，离不开总线。 下面介绍 内存、中央处理器、总线、输入输出设备 内存内存这一个存储区域是线性的。存储数据的基本单位是字节（byte），1字节&#x3D;&#x3D;8位（bit）。每一个字节对应一个内存地址。 内存地址是从0开始的，自增，最后一个地址为总大小 - 1，和数组差不多性质。所以内存读写任何一个数据的速度是一样的 中央处理器即CPU，有32位和64位，区别在于一次能计算多少字节数据。 32位 – 4个字节 64位 – 8个字节 这么设计是为了计算更大的数值。 CPU内部还有常见的如寄存器、控制单元、和逻辑运算单元。 为什么已经有存储器内存存储了，还需要寄存器来存储？ 因为内存离CPU远，计算速度比较慢 常见的寄存器种类： 通用寄存器：用来存放需要进行运算的数据 程序计数器：用来存放CPU要执行的下一条指令的内存地址 指令寄存器：用来存放程序计数器存放的指令，指令本身 总线CPU和内存以及其他设备的通信 分类： 地址总线：用于CPU要操作的内存地址 数据总线：用于读写内存的数据 控制总线：用于发送和接受信号，比如中断、设备复位等信号 读写内存时 地址总线指定内存地址 控制总线控制读写命令 数据总线传输数据 输出输出设备外界与CPU交互，用到了控制总线 线路位宽与CPU位宽数据通过线路传输是通过操作电压完成，低电压是0，高电压是1。 一位一位的传输就是串行方式。想一次多传输就应该增加线路。 为了避免低效率的串行传输方式，线路的位宽最好一次就能访问到所有的内存地址。 CPU要操作内存地址就需要地址总线： 如果地址总线只有一根，能够表示的只有0 和 1所以能够操作的内存地址最大为2，不是同时操作的地址。 两条就是 00 01 10 11 四个地址， 即2 ^ 根数 那么要操作4g内存，就需要32条总线，2 ^ 32 &#x3D; 4 G 上面的是线路位宽，下面是CPU位宽 CPU的位宽不应该小于线路位宽，因为32位的CPU一次只能操作32位的地址总线和数据总线 32位如何计算64位大小的数字？拆分成高低位，然后先算地位，再算进位，再算高位。 而64位CPU就能一次性计算。 所以如果32位和64位一起计算32位可能没什么差别，但是当计算64位时64位才会有优势。 另外，32位CPU最大只能操作4GB内存条，装了8g也没有用。64位则是2^64 程序执行的基本过程 第一步，CPU根据程序计数器获取到存储指令的内存地址，然后控制单元操作地址总线访问内存地址，通知内存准备数据，准备好数据后，通过数据总线将指令内容传给CPU，CPU收到后存入到指令寄存器 CPU分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算，如果是存储类型的指令，就交给控制单元执行。 第三步，CPU执行完指令后，程序计数器自增，表示指向下一条指令，大小由CPU位宽决定，比如32位CPU，一条指令大小就是4字节，需要4个地址存放，程序计数器就自增4 这个往复过程就是CPU的指令周期 a &#x3D; 1 + 2执行具体过程首先CPU是不认识 a &#x3D; 1 + 2的，所以要想跑起程序就需要把整个程序翻译成汇编语言，整个过程就叫汇编。 针对汇编代码，需要汇编器翻译成机器码，由01组成，这个就是计算机指令，CPU能够认识。 a &#x3D; 1 + 2 在 32位CPU的执行过程：程序编译过程中，编译器通过分析代码，能够发现1 和 2 是数据，内存会有个叫数据段的区域来存放这些数据。 如图 数据 1 被存放到 0x100 位置； 数据 2 被存放到 0x104 位置； 存放指令的地方叫正文段 存放数据的地方叫数据段 编译器会把a &#x3D; 1 + 2 翻译成4条指令存放到正文段。 0x200 load 将数据1 装入 R0寄存器 0x204 load 将数据2 装入 R1寄存器 0x208 add 将R0 和 R1 相机，并把结果放到寄存器R2 0x20c store 将寄存器R2的数据存回0x108地址就是变量a的地址 再提一句就是，32位CPU一条指令4个字节，也就是4个内存地址 指令指令其实指的是机器码，但是为了方便理解，这里说的是汇编代码。CPU通过解析机器码来知道指令的内容。 不同的CPU有不同的指令集，也对应不同的机器码，下面是最简单的MIPS指令集，来了解机器码是如何生成的。 MIPS 的指令是一个 32 位的整数，高 6 位代表着操作码，表示这条指令是一条什么样的指令，剩下的 26 位不同指令类型所表示的内容也就不相同，主要有三种类型R、I 和 J。 R指令，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移后面还有唯一操作的位移量，最后的功能码则是前面的操作码不够的时候，扩展操作码来表示对应的具体指令的。 I指令，用在数据传输、条件分支等。没有位移量、功能码、和第三个寄存器。三部分合并成一个地址值或一个常数 J指令用于跳转，后面26位全表示跳转后的地址 下面举例：add指令将寄存器R0和R1的数据相加，并把结果放入到R2，翻译成机器码 加和运算add指令属于R指令类型 编译器在编译程序的时候会构造指令，CPU执行时会解析指令。指令的编码与解码。 在此基础上，现代大多是CPU都是使用流水线的方式来执行指令。 四个阶段的具体含义？ 通过程序计数器读取响应内存地址的指令 Fetch 取得指令 对指令进行解码 Decode 指令译码 执行指令 Execution 执行指令 将计算结果放入寄存器或者内存，Store 数据回写 上面4个步骤叫做指令周期。 不同阶段由不同计算机组件完成： 指令都是存储在存储器中，通过程序计数器和指令寄存器取指令的过程都是由控制器操作的。 译码–控制器 执行时，算术由算术逻辑单元负责，跳转啥的由控制器负责 指令的类型从功能出发，和上面不要混肴，上面有一个是指令集，是具体的体现： 数据传输类型 store&#x2F;load 寄存器与内存 mov 内存与内存 运算类型 加减乘除 跳转类型 if-else swit-case 函数调用 信号类型 trap 中断 闲置类型 nop CPU空转 指令的执行速度CPU的硬件参数GHZ ，1GHZ表示1秒能够产生1G次脉冲信 号，每一次脉冲信号高低电平的转换就是一个时钟周期。 CPU在一个时钟周期内，只能完成一次最基本的动作，时钟频率越高时钟周期越短，工作速度越快。 一个时钟周期能够执行一条指令吗？ 不能。大多数指令都不能，而且不同的指令需要的时钟周期也不一样。乘法比加法多。 如何让程序跑的更快？ 消耗的CPU时间少，说明程序是快的，对于程序的CPU执行时间可以拆解成CPU时钟周期数和时钟周期时间的乘积 时钟周期时间即主频。主频越高说明运行速度越快。比如2.4GHZCPU，时钟周期时间就是 1&#x2F;2.4G 但是主频一般来说是相对固定的，所以我们应该去减少CPU时钟周期数。 CPU时钟周期数 &#x3D; 指令数 * 每天指令的平均时钟周期数CPI 那对于如何让程序跑的更快这个问题的答案就出来了？ 指令数，可以靠编译器，同样的代码在不同的编译器中编译出来的指令不一样 每条指令的平均时钟周期数CPI：大多数CPU已使用流水线技术，让一条指令所需要的CPU时钟周期数尽可能的少。 时钟周期时间：超频技术，打开超频意味着把CPU内部时钟调快了。代价是热量和崩溃。 很多厂商为了跑分而跑分，基本都是在这三个方面入手的哦，特别是超频这一块 总结1.2 磁盘比内存缓慢几万倍？1 2","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"硬件结构","slug":"硬件结构","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"Springboot","slug":"Springboot","permalink":"http://example.com/categories/Springboot/"},{"name":"netty","slug":"netty","permalink":"http://example.com/categories/netty/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://example.com/tags/Springboot/"},{"name":"异步回调","slug":"异步回调","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"},{"name":"Future","slug":"Future","permalink":"http://example.com/tags/Future/"},{"name":"Reactor模式","slug":"Reactor模式","permalink":"http://example.com/tags/Reactor%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JavaNIo","slug":"JavaNIo","permalink":"http://example.com/tags/JavaNIo/"},{"name":"netty","slug":"netty","permalink":"http://example.com/tags/netty/"},{"name":"零拷贝","slug":"零拷贝","permalink":"http://example.com/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"name":"IO模型","slug":"IO模型","permalink":"http://example.com/tags/IO%E6%A8%A1%E5%9E%8B/"},{"name":"硬件结构","slug":"硬件结构","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/"}]}